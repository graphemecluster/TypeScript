=== tests/cases/compiler/noIterationTypeErrorsInCFA.ts ===
interface F {
    d(): void
>d : () => void
}
export function doRemove(dds: F | F[]) {
>doRemove : (dds: F | F[]) => F[]
>dds : F | F[]

    if (!Array.isArray(dds)) {
>!Array.isArray(dds) : boolean
>Array.isArray(dds) : boolean
>Array.isArray : { <T>(arg: T): arg is T extends any ? Extract<true extends false & T ? any[] : T extends readonly any[] ? T : T extends string ? never : T extends ArrayLike<infer U> ? U[] : unknown[], T> : never; <T>(arg: T): arg is T extends any ? Extract<true extends false & T ? any[] : T extends readonly any[] ? T : T extends string ? never : T extends ArrayLike<infer U> | Iterable<infer U> ? U[] : unknown[], T> : never; }
>Array : ArrayConstructor
>isArray : { <T>(arg: T): arg is T extends any ? Extract<true extends false & T ? any[] : T extends readonly any[] ? T : T extends string ? never : T extends ArrayLike<infer U> ? U[] : unknown[], T> : never; <T>(arg: T): arg is T extends any ? Extract<true extends false & T ? any[] : T extends readonly any[] ? T : T extends string ? never : T extends ArrayLike<infer U> | Iterable<infer U> ? U[] : unknown[], T> : never; }
>dds : F | F[]

        dds = [dds]
>dds = [dds] : F[]
>dds : F | F[]
>[dds] : F[]
>dds : F
    }
    for (let n of dds) {
>n : F
>dds : F[]

        n.d()
>n.d() : void
>n.d : () => void
>n : F
>d : () => void
    }
    return dds
>dds : F[]
}

